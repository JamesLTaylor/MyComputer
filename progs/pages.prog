::PAGE0
*pg_stack_ptr = 0
*pg_stack = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]  # location to return to. page and address
*return_pg = 0
*return_addr = 0
RDV A pg_stack
RDV M1 pg_stack_ptr
ADM A
WRT R             # pg_stack_ptr now has address of head of stack
NOP

::MAIN
*pos = 6
*list1 = [25 250 2500]
*list2 = [17 27 270]
*results = [0, 0, 0]

# paging section
:PAGE_OUT
# pop the target page, put this page in R
RDV R MAIN        # this page
RDV M0 PAGE0
RDV M1 pg_stack_ptr
RDM M1            # pointing to top of stack
RDM P1            # jump to page at top of stack
:PAGE_LAND        # this is where someone paging in will land
JMZ R RETURN
WRT R             # replace top of stack with contents of R
RDV P1 CONTINUE
:RETURN
RDV M1 pg_stack_ptr
RDM A
ADV A -2
WRT A
:CONTINUE

# start of program
:START
RDV M0 MAIN
RDV A list1.0
RDV M1 pos
ADM A
CPY R M1
RDM A
RDV M0 SUBTRACT
RDV M1 a.0
WRT A

RDV M0 MAIN
RDV A list2.0
RDV M1 pos
ADM A
CPY R M1
RDM A
RDV M0 SUBTRACT
RDV M1 b.0
WRT A

# now put SUBTRACT on the page stack and jump
RDV M0 PAGE0
RDV M1 pg_stack_ptr
RDM A
ADV A 2
WRT R
CPY R M1
RDV A SUBTRACT
WRT A
RDV P1 PAGEOUT
:PAGERETURN

RDV M1 pos
RDM A
ADV A -2
WRT R
JMZ R FINISHED
RDV P1 START
:FINISHED
HLT

:SUBTRACT_JUMP
# set target page
RDV M0 PAGE0
RDV M1 target_page
RDV A SUBTRACT
WRT A
# set return page
RDV M1 source_page.0
RDV A MAIN
WRT A
RDV M1 source_page.1
RDV A SUBTRACT_CONTINUE
WRT A
# jump to paging
RDV P1 PAGING
:SUBTRACT_CONTINUE



# Copy values to a, b
RDV P1 SUBTRACT_JUMP

:CONTINUE

::SUBTRACT  # a routine on its own page. You should write to a and b then read from result when it returns
*a = 20000
*b = 10000
*neg_b = 0
*result = 0

# Negate b
RDV M1 b.0
RDM A       # A has low bits of b
NEG A
RDV M1 neg_b.0
WRT R
RDV M1 b.1
RDM A       # A has high bits of b
NEG A 1
RDV M1 neg_b.1
WRT R

# Add a to -b
ADV A 0    # clear ADD carry bit
RDV M1 a.0
RDM A
RDV M1 neg_b.0
ADM A
RDV M1 result.0
WRT R
RDV M1 a.1
RDM A
RDV M1 neg_b.1
ADM A
RDV M1 result.1
WRT R
